<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>jωiXML processor - Help</title>
      <link rel="stylesheet" href="../jwiXML.css" type="text/css"/>
      <link rel="stylesheet" href="./jwiXML-help.css" type="text/css"/>
   </head>
   <body id="helpPage"><!--DO NOT EDIT. Generated from file:/D:/Saxonica/InvisibleXML/Mine/help/jwiXML-help-master.xhtml-->
      <div>
         <h2>
            <a href="https://invisiblexml.org/">
               <img src="../logos/logo_gradient.png"
                    alt="InvisibleXML Logo"
                    width="60pt"/>
            </a>
            <span style="font-style:italic">j</span>ω<img src="../logos/logotype.png" alt="InvisibleXML Logo" width="60pt"/> processor - HELP</h2>
         <p id="status" class="note">An interactive SaxonJS/JavaScript workbench processor of <a href="https://invisiblexml.org/">Invisible XML</a> - Workbench Version 1.4</p>
      </div>
      <h2>Table of Contents</h2>
      <ul>
         <li>
            <a href="#d2e44">Introduction</a>
         </li>
         <li>
            <a href="#d2e86">Editing grammars and inputs</a>
         </li>
         <li>
            <a href="#d2e128">Parsing an input against a grammar</a>
            <ul>
               <li>
                  <a href="#d2e134">Parsing and compiling the grammar</a>
               </li>
               <li>
                  <a href="#d2e180">Parsing the input string against the grammar</a>
               </li>
            </ul>
         </li>
         <li>
            <a href="#d2e192">Errors</a>
            <ul>
               <li>
                  <a href="#d2e198">Grammar errors</a>
               </li>
               <li>
                  <a href="#d2e270">Input parsing errors</a>
               </li>
               <li>
                  <a href="#d2e300">Serialisation errors</a>
               </li>
            </ul>
         </li>
         <li>
            <a href="#d2e322">Actions</a>
         </li>
         <li>
            <a href="#d2e354">Options</a>
         </li>
         <li>
            <a href="#d2e501">Loading grammars and inputs from external sources</a>
            <ul>
               <li>
                  <a href="#d2e528">Grammars in XML</a>
               </li>
            </ul>
         </li>
         <li>
            <a href="#d2e547">Notes on the XPath/XQuery 4 grammars</a>
            <ul>
               <li>
                  <a href="#d2e606">Failures</a>
               </li>
               <li>
                  <a href="#d2e625">Ambiguities</a>
               </li>
               <li>
                  <a href="#d2e650">The Set-subtraction operator</a>
               </li>
            </ul>
         </li>
         <li>
            <a href="#d2e687">Change history</a>
            <ul>
               <li>
                  <a href="#d2e691">Version 1.1 - 2022nov01</a>
               </li>
               <li>
                  <a href="#d2e709">Version 1.3 - 2023may27</a>
               </li>
               <li>
                  <a href="#d2e727">Version 1.4 - 2024feb13</a>
               </li>
               <li>
                  <a href="#d2e794">Version 1.5 - 2024sep23</a>
               </li>
            </ul>
         </li>
      </ul>
      <p>TODO:</p>
      <ul>
         <li>Look into adding an undo facility</li>
      </ul>
      <section>
         <h3>
            <a id="d2e44">Introduction</a>
         </h3>
         <div>
            <p>For the runtime files for the iXML processor and a sample <em>j</em>ωiXML application
               see <a href="https://github.com/johnlumley/jwiXML">here</a>.</p>
         </div>
         <div>
            <p>This workbench runs <i>entirely</i> within the browser client, using <a href="https://www.saxonica.com/saxon-js/documentation2/index.html">SaxonJS </a>as
               the top-level program and the <i>jwiXML</i> JavaScript library. There is <i>no</i>
               server-side processing, apart from initial delivery of necessary files.</p>
            <p>You can input and edit an iXML grammar either <i>ab initio</i> or by loading from a
               file on your computer or one of the test-case or sample grammars from the <a href="https://github.com/invisibleXML/ixml">iXML GitHub repository</a>. The input
               string can also be edited or loaded from file or, in the case of a test-case or
               sample grammar, by selecting from one of a number of provided input strings, relevant
               to the grammar in question.</p>
            <p>Local file selection is either by a conventional selector dialog or by drag-and-drop
               of a file onto the relevant text area. (Note that on Firefox security hurdles may
               preclude drag-and-drop.)</p>
         </div>
      </section>
      <section>
         <h3>
            <a id="d2e86">Editing grammars and inputs</a>
         </h3>
         <div>
            <p>
               <span style="text-decoration:underline">iXML grammars</span> are edited in the upper
               textarea, where usual keystokes are supported, but there is no 'syntax awareness'
               during input:</p>
            <img width="400" src="img1.png"/>
            <p>The 'format' button above the textarea will, for a valid grammar, 'pretty-print' by
               replacing the text with a canonical <em>ixml</em> rendering of the parsed grammar.
               This form will line up all the rules so all their names are right aligned and their
               definitions left-aligned. Strings should be enclosed in the quotation characters used
               in the original (doubling such characters within the string as necessary). For
               alternatives, the separator character used is the first separator character (i.e.
               <code>';'</code> or <code>'|'</code>) encountered whilst parsing that set of
               alternatives. If the serialisation of the definition of a rule will be longer than 50
               characters, top-level alternatives will have a newline and appropriate indentation
               attached to their separators. </p>
            <p>This means that, for instance, an original line of the form: </p>
            <pre>a: [L] | "s" ; '"', #a; bcdef ; bcdef ,"a", bcdef; bcdef, "b", bcdef.
bcdef: [N]|("1"; "2" | "3").</pre>
            <p>will be formatted to </p>
            <pre>     a: [L]| 
        "s"| 
        '"',#a| 
        bcdef| 
        bcdef,"a",bcdef| 
        bcdef,"b",bcdef. 
 bcdef: [N]| ("1";"2";"3"). </pre>
            <p>
               <span style="text-decoration:underline">Input strings</span> to be parsed by that
               grammar are edited in the lower text-area:</p>
            <img width="300" src="img2.png"/>
            <p>The size of both of the textareas can be adjusted (at least on Chrome and Firefox) by
               the resizer 'chevron' at the lower right hand corner.</p>
         </div>
      </section>
      <section>
         <h3>
            <a id="d2e128">Parsing an input against a grammar</a>
         </h3>
         <p>With the grammar and potential input string edited, clicking on the GO! button causes
            the following actions:</p>
         <section>
            <h4>
               <a id="d2e134">Parsing and compiling the grammar</a>
            </h4>
            <p>The grammar defined by the text in the Grammar window is parsed and compiled as an
               iXML grammar to produce an internal object representing the compiled grammar.
               Assuming the grammar has valid iXML syntax, this is then displayed in the 'Grammar
               Details' section (which is normally hidden - just click on the bar to reveal or
               hide).</p>
            <p> Here various projections of the grammar can be displayed either in XML format or an
               iXML textual serialisation, or a colour-highlighted iXML form. Either the original
               parsed grammar or the compilation (i.e. where the grammar has been reduced to a
               canonical form) thereof can be shown.:</p>
            <table>
               <tbody>
                  <tr>
                     <td>
                        <img width="250" src="img3.png"/>
                     </td>
                     <td>
                        <img width="250" src="img4.png"/>
                     </td>
                  </tr>
                  <tr>
                     <td>
                        <img width="250" src="img5.png"/>
                     </td>
                     <td>
                        <img width="250" src="img5a.png"/>
                     </td>
                  </tr>
               </tbody>
            </table>
            <p>If you want to copy the parsed XML-format grammar the 'select grammar' button will
               select the whole of the grammar XML, so a simple 'Copy' keystroke action can get it
               into the clipboard as text.</p>
            <img width="300" src="img6.png"/>
         </section>
         <section>
            <h4>
               <a id="d2e180">Parsing the input string against the grammar</a>
            </h4>
            <p>Assuming the grammar has compiled and the input text string is not empty (or the
               'Allow an empty string as input' option is checked), the text string is then parsed
               against the grammar, giving results in the Results section.</p>
            <img width="300" src="img7.png"/>
            <p>As with the parsed grammar, if you want to copy the resulting XML, the 'select
               result' button will select the whole of the result XML (and multiples if ambiguous or
               record-oriented processing was performed), so a simple 'Copy' keystroke action can
               get it into the clipboard as text.</p>
         </section>
      </section>
      <section>
         <h3>
            <a id="d2e192">Errors</a>
         </h3>
         <p>There are three main categories of errors detected:</p>
         <section>
            <h4>
               <a id="d2e198">Grammar errors</a>
            </h4>
            <p>Errors in the iXML grammar presented will be displayed under the 'Grammar Details'
               section. Such errors can be one of: </p>
            <ul>
               <li>The input grammar text supplied does not match the grammar for an iXML grammar.
                  In this case the reported error will attempt to identify why and where the parsing
                  of that grammar failed, such as:<pre class="grammarFailure">Grammar failure G000: 
Invalid rule syntax. Missing rule terminator character.
Expecting character:'.' - given: 'p' (codepoint 112).
Near line 9, column 2.
product: term, "×", operand.
 ^</pre> and <pre class="grammarFailure">Grammar failure S10: 
A Unicode character category code must match [A-Z][a-z]?. Provided: 'LZ'.
Near line 11, column 8.
id: [LZ].
       ^</pre>
               </li>
               <li>
                  <p>The grammar supplied, whilst grammatically correct (i.e. its text parses
                     correctly) is invalid. Such cases include</p>
                  <table class="options">
                     <thead>
                        <tr>
                           <th>Condition</th>
                           <th>Example</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td>There are references to non-terminals for which a rule definition has
                              not been provided.</td>
                           <td class="grammarFailure">
                              <pre>Grammar failure S02: 
No production rules for non-terminals: number</pre>
                           </td>
                        </tr>
                        <tr>
                           <td>There are multiple rule definitions for a non-terrminal.</td>
                           <td class="grammarFailure">
                              <pre>Grammar failure S03: 
Adding productions for an already-defined non-terminal: id</pre>
                           </td>
                        </tr>
                        <tr>
                           <td>There are non-terminal rule definitions which are unreachable through
                              reference from the starting rule. This will only be detected if the
                                 <em>Prohibit unreachable non-terminals</em> option has been
                              checked.</td>
                           <td class="grammarFailure">
                              <pre>Grammar failure S002: 
Unreachable production rules for non-terminals: b</pre>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e270">Input parsing errors</a>
            </h4>
            <p>The parsing of an input string against a valid iXML grammar can fail for a number of
               reasons. Such errors are displayed in the 'Result' portion of the workbench,
               currently as, in line with the specification, an XML document with
               <code>@ixml:state="failed"</code> on the topmost element, such as:</p>
            <pre class="parseFailure">&lt;ixml xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
Failure at line 1 column 2
Given '/' (codepoint 47). Expecting one of:
   "+" {#8: sum: term, "+", term++"+".},
   "×" {#10: product: term, "×", operand.},
   [&lt;=&gt;≠≤≥] {#4: compare: ["&lt;=&gt;≠≤≥"].}
Input:
   a/b
    ^
&lt;/ixml&gt;</pre>
            <p>where an unexpected (operator) character was encountered. In this case the processor
               attempts to identify what characters would have been admissable at this point in the
               parse, and in which rules (identified by line number and with original source) the
               parse failed. (This is currently not available for internally-generated rules, such
               as those for repetition constructs.) </p>
            <p>In cases of high potential ambiguity, such as the grammar:</p>
            <pre>specification: "{", rule*, "}".
rule: definition*.
definition: id, "=", value.
id:[L].
value:[N].</pre>
            <p>when run with an input that can trigger such ambiguity, such as <code>{}</code>
               (possible solutions could include no rule or a potentially infinite sequence of rules
               each containing no definitions) the <em>j</em>ωiXML processor can get into an
               infinite loop. Internally there is a limit of triggering 1000 productions on
               processing a character from the input string. If this limit is reached a failure will
               assumed: </p>
            <pre class="parseFailure">&lt;ixml xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
Probable looping processing character '{' @ line 1, column 1&lt;/ixml&gt;</pre>
         </section>
         <section>
            <h4>
               <a id="d2e300">Serialisation errors</a>
            </h4>
            <p>The input string may have parsed correctly, but it is still possible that the
               conversion (serialisation) to XML fails as the resulting tree would not be a valid
               XML document. In such cases the error is reported, again in the 'Result' section:</p>
            <pre class="parseFailure">&lt;ixml xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
An attribute node may not be the final parse result @input&lt;/ixml&gt;</pre>
            <p>or</p>
            <pre class="parseFailure">&lt;ixml xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
Multiple nodes may not be the final parse result:&lt;expression/&gt;,@compare,&lt;expression/&gt;&lt;/ixml&gt;</pre>
            <p>Note that when <em>'Treat as records'</em> is enabled, multiple document trees can be
               generated and will be serialised in sequence in the result display.</p>
         </section>
      </section>
      <section>
         <h3>
            <a id="d2e322">Actions</a>
         </h3>
         <p>The following actions on grammars displayed in the grammar textbox are supported via
            simple buttons:</p>
         <table class="actions">
            <thead>
               <tr>
                  <th>Action</th>
                  <th>Effect</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td class="action">reformat</td>
                  <td>Pretty-print the ixml grammar to a standard format, where
                  all rule names are right-aligned, and non-simple (non-terminal and multiple
                  terminals) top-level alternatives are placed on newlines</td>
               </tr>
               <tr>
                  <td class="action experimental">reduce</td>
                  <td>Transform the given grammar into a
                  'reduced tree' version (which will have most single-child parent elements
                  removed). See the section "Truncation of Deep Trees" of <a href="https://www.balisage.net/Proceedings/vol29/html/Lumley01/BalisageVol29-Lumley01.html">“Variations on an Invisible Theme"</a> for more details</td>
               </tr>
            </tbody>
         </table>
      </section>
      <section>
         <h3>
            <a id="d2e354">Options</a>
         </h3>
         <p>The following options controlling grammar parsing, input string treatment and result
            display are supported via checkboxes. Where appropriate the corresponding option or
            invocation in the <em>jwiXML.processor</em> API is described:</p>
         <table class="options">
            <thead>
               <tr>
                  <th>Option</th>
                  <th>Default</th>
                  <th>Effect</th>
                  <th>API equivalent</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td class="option">Show Advanced options</td>
                  <td class="false"/>
                  <td> Make the advanced (<span class="experimental">and experimental</span>) options visible. Ordinarily these
                  shouldn't be needed - the defaults maximise the comformity of the processor. See
                  the table below for a description of these options. </td>
               </tr>
               <tr>
                  <td class="option">Prohibit unreachable non-terminals</td>
                  <td class="false"/>
                  <td> When checked, all non-terminals in the
                  grammar must be reachable through a reference path from the start (first) rule. </td>
                  <td>compile() option 'unreachable'</td>
               </tr>
               <tr>
                  <td class="option">Allow an empty string as input</td>
                  <td class="false"/>
                  <td> Normally if the
                  input is an empty string, no attempt is made to parse - just the grammar is
                  processed and displayed. Checking this allows processing of an empty string as
                  input, which is probably only needed for certain test cases. </td>
               </tr>
               <tr>
                  <td class="option">Treat as records</td>
                  <td class="false"/>
                  <td> When checked, the input is assumed
                  to be a sequence of records separated by character sequences which match a given
                  regular expression (for which <em>'\n'</em> is the default). The separator can be
                  edited in the displayed text input, when this option is selected. <br/>The result
                  is a <em>sequence</em> of documents, each serialised in the output result area as
                  children of the 'parent' element, which can be edited<br/>For repetitively
                  structured data where the repetition separators do not appear in the data
                  'records' this technique can be <em>vastly</em> more efficient than describing the
                  repetition/separation in the iXML grammar itself. </td>
                  <td>parseRecords() 3rd argument $separator</td>
               </tr>
               <tr>
                  <td class="option">Show only one ambiguous solution</td>
                  <td class="false"/>
                  <td> When the parse is ambiguous, with multiple
                  possible solutions, this forces only one to be returned, which will still be
                  marked as ambiguous. </td>
                  <td>parse() option 'justOne'</td>
               </tr>
               <tr>
                  <td class="option">Indent result</td>
                  <td class="true"/>
                  <td> When checked, the results will be
                  displayed as a serialization of the XML tree with indentation applied. This means
                  that whitespace-only text nodes may be altered or in some cases deleted. If your
                  application requires strict whitespace preservation, uncheck this option. </td>
               </tr>
               <tr>
                  <td class="option">Indent with a single space per level</td>
                  <td class="false"/>
                  <td> When checked,
                  the results, if indented, will be displayed with a single additional space of
                  indentation per tree-level depth (as opposed to the default 3.) This is intended
                  to make very deep trees display 'narrower' in the serialisation (and avoid really
                  wide scrolling displays). </td>
               </tr>
            </tbody>
         </table>
         <table class="options">
            <thead>
               <tr>
                  <th>Advanced Option</th>
                  <th>Default</th>
                  <th>Effect</th>
                  <th>API equivalent</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td class="option">Permit missing non-terminals</td>
                  <td class="false"/>
                  <td> When checked, missing non-terminals may be
                  referenced in the grammar (e.g. for experimentation in grammar combination).
                     <strong>Using this during input parsing will lead to unpredictable results -
                     usually some sort of crash.</strong>
                  </td>
                  <td>compile() option 'missing'</td>
               </tr>
               <tr>
                  <td class="option">Tovey-Walsh rewrites</td>
                  <td class="true"/>
                  <td> When checked, <code>f+</code> constructs are
                  rewritten as <code>f+ =&gt; f-plus. f-plus: f, f-plus| ().</code> rather than the
                  <code>f-plus: f, f*.</code> rewrite given in the spec. This is currently the
                  default, as it seems to perform significantly quicker. </td>
                  <td>compile() option 'twRewrites'</td>
               </tr>
               <tr>
                  <td class="option">Show Parser States</td>
                  <td class="false"/>
                  <td> Displays the internal state
                  transitions of the Earley parser operating on the input. This is
                     <strong>NOT</strong> recommended for use with large grammars and inputs as
                  memory overflows can be encountered.</td>
               </tr>
               <tr>
                  <td class="option">Show all processed marks</td>
                  <td class="false"/>
                  <td> If checked, directive marks for deletion
                  ('-'), attribute ('@') or rename aliasing ('&gt;') serialisation of
                     <strong>non-terminals</strong>, or deletion ('-') or insertion ('+')
                  serialisation of <strong>quoted strings</strong> are not honoured but rather
                  placed on the full parse tree output either as an <code>@ixml:mark</code> or
                  <code>@ixml:alias</code> attribute or an <code>ixml:insert</code> or
                  <code>ixml:delete</code> element. <br/>This ony applies to marks on the original
                  grammar and not to artefactual marks generated in compiling the grammar, such as
                  those used for generated non-terminals implementing optionality or
                  repetition.</td>
                  <td>parse() option 'suppressMarks''</td>
               </tr>
               <tr>
                  <td class="option">Support iXML version 1.1</td>
                  <td class="false"/>
                  <td> Support additional
                  features of iXML version 1.1 (e.g. renaming)</td>
               </tr>
               <tr>
                  <td class="option experimental">Keep multi-character strings</td>
                  <td class="false"/>
                  <td> Multi-character terminal strings
                  (corresponding to the <code>quoted</code> production of the iXML spec.) are
                  expanded during compilation to a sequence of single (<code>quoted</code>)
                  character strings, to correspond to a character-by-character processing of the
                  Earley parser. If this option is checked such strings are retained as multiple
                  characters and the Earley parser 'jumps-forward' to write a new state several
                  character positions forward in its state records.</td>
                  <td>compile() option 'longStrings'</td>
               </tr>
               <tr>
                  <td class="option experimental">Use regular expression matches</td>
                  <td class="false"/>
                  <td> Uses regular expression matching for quoted
                  strings, inclusions and exclusions and in some cases repetition and optional forms
                  of the same. <strong>This will only work properly when the ranges of characters
                     matched by the following term in sequence can be guaranteed disjoint with that
                     of the current term.</strong> Automatic determination of safe conditions to do
                  this is a type-analysis research issue.</td>
                  <td>compile() option 'regEx'</td>
               </tr>
               <tr>
                  <td class="option experimental">Max state loops</td>
                  <td>1000</td>
                  <td>Set the limit on the number of state-generating
                  processing loops per input character during the parse. If this limit is exceeded,
                  the parse will terminate.</td>
                  <td>parse() option 'loopLimit'</td>
               </tr>
               <tr>
                  <td class="option experimental">Parse timeout/ms:</td>
                  <td>4000</td>
                  <td>Set the time limit (in milliseconds) for the
                  complete parse. At the completion of each character of input this timeout is
                  checked - if exceeded, the parse will terminate. Due to the single-thread nature
                  of JavaScript, this is the only way, without significant overhaul of the entire
                  parser architecture, to limit runaway parsing in cases of very high
                  ambiguity.</td>
                  <td>parse() option 'parseTimeout'</td>
               </tr>
            </tbody>
         </table>
      </section>
      <section>
         <h3>
            <a id="d2e501">Loading grammars and inputs from external sources</a>
         </h3>
         <p>Both grammar and input texts can be read from local filestore by using the appropriate
            'Choose file' (or 'Browse') button, which permits a file to be read and its text loaded
            into the textarea. The name of the file loaded is displayed next to the file chooser.
            Files can also be 'drag-and-dropped' onto the textarea, though in Firefox security
            settings will probably have to be altered (it seems to work fine in Chrome).</p>
         <img width="300" src="img8.png"/>
         <p>Grammars can also be loaded from web-repositories, in particular from the <a href="https://github.com/invisiblexml/ixml/">InvisibleXML test-suites or sample
               grammars</a> using the Grammar 'Test/sample' dropdown:</p>
         <img width="300" src="img9.png"/>
         <p>A <a href="https://invisiblexml.org/test-catalog/">browsable catalog</a> of the test
            suite is also available.</p>
         <p>When there are sample inputs available for one of these test or sample grammars, the
            'Test/Sample' dropdown above the Input textarea will be populated.</p>
         <img width="300" src="img10.png"/>
         <section>
            <h4>
               <a id="d2e528">Grammars in XML</a>
            </h4>
            <p>Note that some of these test cases provide the iXML grammar in its XML serialisation
               form. The workbench recognises such a situation and will show and use that form, but
               editing in the textarea under these circumstances will have <em>no effect on the
                  grammar being used in parsing</em>. Files containing iXML grammars serialised as
               XML loaded by other means (file selection, drag-and-drop) will be (currently) treated
               as simple text and currently will therefore fail to be parsed. (The <a href="https://github.com/johnlumley/jwiXML">jwlProcessor.xsl</a> library contains
               a <code>jwl:parseXML()</code> function that <strong>will</strong> accept
               XML-serialised grammars)</p>
         </section>
      </section>
      <section>
         <h3>
            <a id="d2e547">Notes on the XPath/XQuery 4 grammars</a>
         </h3>
         <p>I've been involved in the <a href="https://qt4cg.org/">QT4 Community Group</a> since its
            start, and have been using the grammars for XPath and XQuery as large test examples for
            this iXML processor. These grammars are also available to support experimentation for
            those involved in that community to perhaps handle 'what-if' experiments on the
            grammar.</p>
         <p>The 'Test/Sample' dropdown contains (at the top) iXML grammars for the 'near-current'
            draft 4.0 versions of the Xpath and XQuery grammars. These are derived programmatically
            (with a modicum of automated patching) directly from the grammar definitions used to
            generate the specification grammars <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-grammar">XPath
               EBNF</a> and <a href="https://qt4cg.org/specifications/xquery-40/xquery-40.html#id-grammar">XQuery
               EBNF</a>. (See my <a href="https://www.balisage.net/Proceedings/vol29/html/Lumley01/BalisageVol29-Lumley01.html">Balisage paper</a> for details of how these are constructed.)</p>
         <p>The grammars are presented in three different versions of iXML:</p>
         <ul>
            <li>
               <code>1.0</code>, the published standard,</li>
            <li>
               <code>1.1</code>, the current draft which noteably adds the ability to rename
               nonterminals (<code>A&gt;b</code>). This is used in areas such as <code>QName</code>s to
               accomodate both prefix and local parts as attributes, and</li>
            <li>
               <code>1.1+</code>, being the <code>1.1</code> version with the addition of a
               set-subtraction operator (see below), which is used to exclude certain reserved
               keywords from nome name concepts, such as <code>function</code> being reserved from
               use a the name of a function call. As far as I'm aware, <b>this iXML feature is not
                  currently supported by any other implementation</b> and whilst having been
               proposed as an additional part of iXML, decisions on it have not yet been made.</li>
         </ul>
         <p>For both these grammars, there is also a 'reduced tree' version which truncates the very
            deep trees that normally result from parsing. A suitable moderately large sample
            expression to test parsing is included for each grammar.</p>
         <p>Each of the (iXML) grammars contains a date-stamp in a comment near the top which can
            be used to verify whether it is 'up to date', by comparison with the history of the
            file: <a href="https://github.com/qt4cg/qtspecs/blob/master/specifications/grammar-40/xpath-grammar.xml">https://github.com/qt4cg/qtspecs/blob/master/specifications/grammar-40/xpath-grammar.xml</a>
         </p>
         <p>Whilst the grammars have been tested across the 35k expressions of the QT4 test sets,
            with only some 50 failures, there are known areas where the grammar fails or produces
            ambiguity. These notes are intended to explain.</p>
         <section>
            <h4>
               <a id="d2e606">Failures</a>
            </h4>
            <ul>
               <li>The iXML grammars (which have to effectively act as their own tokenizers) are
                  very 'whitespace sensitive' and several failures occur when certain operator
                  symbols are directly adjacent to operands. The most common is a minus operator
                  (<code>-</code>) unsurrounded by whitespace, e.g. <code>1-1</code>, but others can
                  include examples such as <code>if(foo)else</code>, etc. Attempting to cure these
                  will give rise to explosive ambiguity, especially in supporting a binary minus
                  without surrounding whitespace. In the 35k tests, these failures occur about 20
                  times. </li>
               <li>Some very long sections of string/content, e.g. fully embedded transforms within
                  a string initializer, can trigger the parser's 'looping' limit (no more than 1000
                  additional states can be propagated for parsing a single character of the input -
                  this can be altered if desired - see the options above.) </li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e625">Ambiguities</a>
            </h4>
            <p>The grammars, lacking a tokenizer and the ability to look-ahead without consumption,
               retain a few ambiguities that are inhernet in the basic EBNF grammars (i.e. without
               notes)</p>
            <ul>
               <li>Function signatures with trailing occurrence indicators
                  <code>fn(){..} as a?</code>
               </li>
               <li>Ambiguity from <code>/*/</code>, where the <code>*</code> can be a wildcard or a
                  multiplication</li>
               <li>Colons in QNames and maps, e.g. <code>map{a:*:c}</code>
               </li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e650">The Set-subtraction operator</a>
            </h4>
            <p>The grammars use an experimental 'set-subtraction' operator <code>¬</code> to
               indicate certain reserved keywords such as limitations on function names: </p>
            <pre>         FunctionCall: EQName ¬ reservedFunctionNames, ArgumentList.
reservedFunctionNames: types |
                       commands.
                types: "attribute"; "comment"; ... .
             commands: "fn"; "function"; "if"; "switch"; "typeswitch".         </pre>
            <p>Removal of the operator and its RH argument will permit the grammar to run on a 1.0
               conformant iXML processor, though now <code>comment()</code> can be ambiguous. The
               operator is currently used on the productions for <code>FunctionCall</code>,
               <code>NamedFunctionRef</code>, <code>DirCommentContents</code>,
               <code>CompPIConstructor</code>, <code>ElementContentChar</code>,
               <code>QuotAttrContentChar</code> and <code>AposAttrContentChar</code> and indirectly
               from <code>CompElemConstructor</code> and <code>CompAttrConstructor</code> (I can
               arrange for such grammars to be generated - let me know if you wish so.)</p>
         </section>
      </section>
      <section>
         <h3>
            <a id="d2e687">Change history</a>
         </h3>
         <section>
            <h4>
               <a id="d2e691">Version 1.1 - 2022nov01</a>
            </h4>
            <ul>
               <li>Improvements to error reporting.</li>
               <li>Revamped help.</li>
               <li>Addition of 'unreachable non-terminals check' option.</li>
               <li>'Pretty-print' reformatting of grammar text.</li>
               <li>Corrected ixml serialisation of multi-part (alts) option and repetition
                  constructs.</li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e709">Version 1.3 - 2023may27</a>
            </h4>
            <ul>
               <li>Tooltip help boxes added.</li>
               <li>Improvements to error reporting,- tracing now identifies original source line in
                  case of expanded repeats and optionals.</li>
               <li>Support for 'Tovey-Walsh' repetition and optional rewrites.</li>
               <li>Addition of 'permit missing non-terminals' option, for grammar combination
                  testing.</li>
               <li>Addition of 'identation suppression' in result XML (for cases with significant
                  whitespace)</li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e727">Version 1.4 - 2024feb13</a>
            </h4>
            <ul>
               <li>Added syntax highlighting option to formatted iXML display</li>
               <li>Corrected an error on syntax reformatting of multi-element repetition separators
                  e.g. <code>body++(s1,s2)</code>
               </li>
               <li>Corrected a state propagation fault that manifested itself in failures in parsing
                  with the XPath grammars when some names were not followed by whitespace. For
                  example parsing the expression <code>a/(b|c)/d</code> failed whereas
                  <code>a/(b |c)/d </code> (<em>trailing space</em>) succeeded</li>
               <li>Added an (XSLT) implementation of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-invisible-xml">fn:invisible-xml()</a> (in the <code>jwL:</code> namespace), corresponding to
                  the signature and semantics given in the current draft of <a href="https://qt4cg.org/specifications/xslt-40/Overview.html">XPath and XQuery
                     Functions and Operators 4.0</a>
               </li>
               <li>Added support for iXML version 1.1 features, most notably the <code>naming</code>
                  production of <a href="https://invisiblexml.org/current/">Invisible XML
                     Specification - Working Draft</a> where <code>name</code>s can have optional
                  <code>alias</code>es to be used in XML tree production. (<span class="experimental">experimental</span>) </li>
               <li>Some tidying up of the workbench interface, including making advanced options
                  hidden by default.</li>
               <li>Added support for processing multi-character quoted strings <em>en-bloc</em>
                  rather than character-by-character(<span class="experimental">experimental</span>) </li>
               <!--<li>Added support for limited forms of pragma (<span class="experimental">experimental</span>) </li>-->
               <li>Added support for limited use of regular expressions in character classes
                  (inclusions and exclusions) and repetititons of both classes and quoted strings
                     (<span class="experimental">experimental</span>) </li>
            </ul>
         </section>
         <section>
            <h4>
               <a id="d2e794">Version 1.5 - 2024sep23</a>
            </h4>
            <ul>
               <li>Corrected <a href="https://github.com/johnlumley/jwiXML/issues/10">issue#10</a>
                  with multiple separators on same nonterminal repetition</li>
               <li>Corrected discarding on some comments in parsed grammar XML</li>
               <li>Supported an expermental 'subtraction' operator <code>A ¬ B</code> which matches
                  if <code>A</code> matches and <code>B</code> does not match at the same
                  end-character position. E.g. <code>[L]+ ¬ "if"</code> will not match
                  <code>if</code>, but will match <code>i</code> or <code>iff</code>. </li>
               <li>Added a 'reduced tree' grammar modification action</li>
               <li>Added a parse timeout and made both timeout and looping ceiling modifiable</li>
               <li>Added 'current' grammars for XPath and XQuery 4.0, and explanatory notes.</li>
            </ul>
         </section>
      </section>
   </body>
</html>
