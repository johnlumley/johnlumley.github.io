<?xml version="1.0" encoding="UTF-8"?>
<tests QT4="https://raw.githubusercontent.com/qt4cg/qt4tests/refs/heads/master"
   XSLT4="https://raw.githubusercontent.com/qt4cg/xslt40-test/refs/heads/master"
   SPEC-XSLT4="https://qt4cg.org/specifications/xslt-40/Overview.html"
   SPEC-FO4="https://qt4cg.org/specifications/xpath-functions-40/Overview.html" title="XSLT">

   <group name="Structure" href="structure/">
      <xslt name="default-namespaces" href="default-namespaces.4.xsl"/>
      <!-- <xslt name="initial template" href="test2.4.xsl"/>
      <xslt name="error" href="test3.4.xsl"/>-->
   </group>

   <group title="Template Rules">
      <group name="Mode" href="modes/">
         <xslt name="enclosed mode" href="enclosed-mode.4.xsl">
            <input name="books" href="$QT4/op/union/bib2.xml"/>
            <input name="works" href="$QT4/op/is-same-node/works.xml"/>
            <input name="staff" href="$QT4/op/is-same-node/staff.xml"/>
            <input name="nw_Customers" href="$QT4/prod/AxisStep/nw_Customers.xml"/>
         </xslt>
      </group>
   </group>

   <group title="Types">
      <group name="Item/Record type" href="record-type/">
         <xslt name="complex numbers" href="complex.4.xsl">
            <input name="addition" href="complex1.xml"/>
            <input name="add/sub" href="complex2.xml"/>
         </xslt>
      </group>
   </group>

   <group name="Callable" href="callable/">
      <xslt name="extension call" href="extensionCT.4.xsl">
         <input name="addition" href="complex1.xml"/>
         <input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>
      </xslt>
      <xslt name="Extension Instructions" href="extensionCT-1.4.xsl">
         <problem>
            <div>Use <spec-xslt ref="invoking-templates-with-extension-instructions">extension
                  instructions</spec-xslt> to construct a series of directories using the named
               template <code>f:directory</code>. Output should be similar to: <pre><![CDATA[<directories>
 <directory country="UK" fields="ContactName Phone">
  <entry>Ann Devon -- (171) 555-0297</entry>
  <entry>Elizabeth Brown -- (171) 555-2282</entry>
  ...
 </directory>
 <directory country="France" fields="ContactName Phone">
  <entry>Daniel Tonini -- 30.59.84.10</entry>
  <entry>Janine Labrune -- 40.67.88.88</entry>
  ...
 </directory>
 <directory country="Germany" fields="City">
  <entry>Berlin</entry>
  <entry>Mannheim</entry>
  <entry>Aachen</entry>
  ...
 </directory>
</directories>]]></pre>
            </div>
            <div>
               <p>For UK and France we want a sorted list of contact name and phone but <i>don't
                     want any managers!</i> and for Germany we just want the cities we have contacts
                  in </p>
               <p>You'll have to set the types of the parameters and calling attribute arguments to
                  get the correct effect.</p>
               <p>This isn't perhaps the most efficient method and we have used
                  <code>xsl:evaluate</code>, but this is showing how extension instructions can be
                  very compact named template calls</p>
            </div>
         </problem>
         <input name="customers" href="../customers.xml"/>
         <!--<input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>-->
      </xslt>
      <xslt solution="" name="Extension Instructions" href="extensionCT-2.4.xsl">
         <input name="customers" href="../customers.xml"/>
      </xslt>
   </group>

   <group name="Conditional" href="conditional/">
      <xslt name="switch" href="switch.4.xsl">
         <input name="months" href="../test3.xml"/>
      </xslt>
   </group>

   <group name="Grouping" href="grouping/">
      <xslt name="split-when" href="split-when.4.xsl"/>
      <xslt name="split-when: line-wrap" href="line-wrap-1.4.xsl">
         <problem>
            <div>Use <spec-xslt ref="xsl-for-each-group">xsl:for-each-group[@split-when]</spec-xslt>
               to line-wrap each <code>para</code> in the input, producing output like:
               <pre>The exercise demonstrates that the
absence of parent or ancestor axes in
the native representation of JSON means
...

JSON has become a significant
alternative to XML as a syntax for data
...
</pre></div>
         </problem>
         <input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>
      </xslt>
      <xslt solution="" name="split-when: line-wrap" href="line-wrap-2.4.xsl">
         <input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>
      </xslt>
   </group>

   <group name="Arrays" href="array/">
      <xslt name="array with for-each" href="array-1.4.xsl"/>
      <xslt name="array/@for-each - duplicate words" href="array-2.4.xsl">
         <problem>
            <div>Use <spec-xslt ref="array-construction">xsl:array</spec-xslt> with
               <code>@for-each</code> to generate lists of duplicate words for each
               <code>para</code>, e.g. <pre><![CDATA[<output>
   <duplicates para="1">and by it The to of for</duplicates>
   <duplicates para="2">are and the by transforming JSON</duplicates>
</output>]]></pre></div>
            <div>You may find the 'parallel' functions to new ones in F&amp;O: <spec-link
                  ref="func-duplicate-values">f:duplicate-values()</spec-link> and <spec-link
                  ref="func-array-members">ar:members()</spec-link> helpful.</div>
         </problem>
         <input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>
      </xslt>
      <xslt solution="" name="array/@for-each - duplicate words" href="array-3.4.xsl">
         <input name="prague" href="$XSLT4/tests/misc/docbook/prague2016mhk.xml"/>
      </xslt>
   </group>

</tests>
